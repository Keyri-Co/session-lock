import Link from 'next/link';
import Head from 'next/head';
import ReactMarkdown from 'react-markdown';

const markdown = `\`session-lock\` is a token binding scheme and JS library that mitigates the risk of session hijacking / token replay attacks by binding the validity of a user's JWT to their browser or device.

Today, the library can be used with any JWT-based authorization system in which you control the JWT generation and verification. The general binding scheme can be used with JWT and cookie-based authorization systems alike, though the library currently only supports JWT-based systems due to the varied ways in which stateful session data is stored server side. The stateless JWT system lends itself well to a general binding scheme that can be implemented in a library.

# Background

As authentication methods become stronger and better MFA is implemented, session tokens become the new weak link in account security. If an attacker can steal a user's session token, they can access protected resources belonging to the user much like they would if they had access to the user's authentication credentials. With the use of OS-level malware, malicious browser extensions, or traffic sniffing, an attacker can steal users' session tokens directly from their browsers or from the network, then use those tokens to authorize their own sessions.

Numerous RFCs have emerged over the years, such as [RFC8471](https://datatracker.ietf.org/doc/rfc8471/), [RFC8472](https://datatracker.ietf.org/doc/rfc8472/), and [RFC8473](https://datatracker.ietf.org/doc/rfc8473/), that aimed to address the issue of session hijacking and token replay attacks. However, these RFCs are not widely adopted (only available in Edge browser), and the solutions they propose are not always practical for the average developer. For example, these three token binding RFCs require modification at the server networking layer, which may be out of reach for a large number of developers. In addition, OAuth 2.0 RFCs such as [RFC6819](https://datatracker.ietf.org/doc/rfc6819/) propose anti-replay token handling practices that yield a stateful session system, which substantially increases the complexity of implementation.

Recently, a [draft RFC](https://datatracker.ietf.org/doc/draft-ietf-oauth-dpop/16/) was published outlining "demonstrating proof-of-possession (DPoP)," which is a significant step in the right direction. The mechanism proposed in the DPoP draft is similar to the token binding scheme proposed in this library, but it is not yet widely adopted and is not yet supported by any major browsers. More importantly, it is only applicable to OAuth 2.0 systems, which are not the only systems that use JWTs. That proposed flow is also more complex in general to implement, involving more steps, moving parts, as well as psuedo-stateful elements.

# How session-lock works
Note: S-L in the diagrams below stands for session-lock.
![](/mermaid-diagram-2023-04-19-164740.svg)
In summary, whereas regular JWTs include a signature generated by the issuing server, session-lock adds a signature generated by the client to which it was issued, with a timestamp added to the mix to make the signature resistant to replay. The client signature is made reliable with the use of unextractable private keys stored in the browser's IndexedDB.

# Try session-lock
session-lock can be demonstrated on this site [here](/auth). Try to take the JWT from LocalStorage and re-use it in another browser or another tab. You will see that the JWT is rejected. This is because the JWT is bound to the browser in which it was issued.

The demo is a simple Next.js app that uses the library to protect a protected route. The protected route is a simple page that displays a message from the server, which is only accessible to users who have a valid session-lock token. The token is generated by the server and stored in the browser's localStorage. The token is then used to make a request to the protected route, which verifies the token and returns the message if the token is valid. The token is valid if the client signature is valid, which is determined by the server verifying that the client signature matches the client's public key, which is stored in the server's database. The client signature is valid if the client's private key is present in the browser's IndexedDB. The client's private key is stored in IndexedDB when the user logs in, and is removed when the user logs out. The client's private key is unextractable, which means that it cannot be extracted from IndexedDB by the server or any other third party. The client's private key is also unextractable from the browser's IndexedDB by the client itself, which means that the client cannot extract the private key from IndexedDB and use it to generate a valid client signature for any token.

# Use session-lock in your own project
session-lock is available as a [library through npm](https://www.npmjs.com/package/session-lock). Full source code and documentation for the library and the demo site can be found on [GitHub](https://github.com/zainazeem/session-lock).
`;

export default function Home() {
  return (
    <>
      <Head>
        <title>session-lock - Home</title>
        <link rel='icon' href='/favicon.ico' />
        <meta
          name='description'
          content='session-lock: a token binding scheme and library'
        />
      </Head>
      <div className='prose prose-invert max-w-none prose-headings:border-b prose-headings:border-gray-600 prose-h1:text-2xl'>
        <ReactMarkdown children={markdown} />
      </div>
    </>
  );
}
