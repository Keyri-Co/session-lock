import Head from 'next/head';
import ReactMarkdown from 'react-markdown';
import rehypeVideo from 'rehype-video';

const markdown = `\`session-lock\` is a token binding scheme and JS library that mitigates the risk of session hijacking / token replay attacks by binding the validity of a user's session token to their browser or device.

The library can be used with both JWTs and serialized cookies, though working with JWTs is a little easier with this library thanks to JWTs' ability to store data within their payloads.

# Background

As authentication methods become stronger and better MFA is implemented, session tokens become the new weak link in account security. If an attacker steals a user's session token, they can access protected resources belonging to the user much like they would if they had access to the user's authentication credentials. With the use of OS-level malware, malicious browser extensions, or traffic sniffing, an attacker can steal users' session tokens directly from their browsers or from the network, then use those tokens to authorize their own sessions.

Session tokens are a weak link in account security, as attackers can steal them to bypass all authentication regardless of how strong it may be and access protected resources. [Existing](https://datatracker.ietf.org/doc/rfc8471/) [RFCs](https://datatracker.ietf.org/doc/rfc8472/) [have](https://datatracker.ietf.org/doc/rfc8473/) [attempted](https://datatracker.ietf.org/doc/rfc6819/) to address the token hijacking threat, but they are not widely adopted and their solutions can be impractical (mostly addressing the networking layer). A draft RFC for [demonstrating proof-of-possession (DPoP)](https://datatracker.ietf.org/doc/draft-ietf-oauth-dpop/16/) proposes a similar mechanism to session-lock, but it is only applicable to OAuth systems and complex to implement.

Here's a manual demonstration of how session hijacking works. In this example, we're taking the the token from a logged-in session and using it on another browser. A bad actor would do this programmatically with a browser extension or malware, but the principle is the same.

https://s3.us-east-2.amazonaws.com/static.keyri.com/session-theft-f.mp4

# Try session-lock
session-lock can be demonstrated on this site [here](/auth). Try to take the JWT from LocalStorage and re-use it in another browser or another tab. You will see that the JWT is rejected. This is because the JWT is bound to the browser in which it was issued.

The demo showcases a Next.js app using a library to secure a protected route, accessible only to users with a valid session-lock token. This token, generated by the server and stored in the browser's localStorage, is verified based on the client signature matching the stored public key. The client's private key, stored in IndexedDB upon login and removed upon logout, is unextractable, ensuring it cannot be misused by the server, third parties, or the client itself.

# Use session-lock in your own project
session-lock is available as a [library through npm](https://www.npmjs.com/package/session-lock). Source code and documentation for the library and the demo site can be found on [GitHub](https://github.com/zainazeem/session-lock).

# How session-lock works
Note: S-L in the diagrams below stands for session-lock. This diagram is JWT-specific in terms of where the client public key is stored and how it's retrieved, but the same principles apply to serial session tokens / cookies as well. 
![](/mermaid-diagram-2023-04-21-153920.svg)
In summary, whereas regular JWTs include a signature generated by the issuing server, session-lock adds a signature generated by the client to which it was issued, with a timestamp added to the mix to make the signature resistant to replay. The client signature is made reliable with the use of unextractable private keys stored in the browser's IndexedDB. The same timestamp+signature can be applied to serialized session tokens / cookies, with the difference being that the client public key is stored in a cookie store on the server rather than embedded within the token itself.
`;

export default function Home() {
  return (
    <>
      <Head>
        <title>session-lock - Home</title>
        <link rel='icon' href='/favicon.ico' />
        <meta
          name='description'
          content='session-lock: a token binding scheme and library'
        />
      </Head>
      <div className='prose prose-invert max-w-none prose-headings:border-b prose-headings:border-gray-600 prose-h1:text-2xl'>
        <ReactMarkdown rehypePlugins={[[rehypeVideo, { details: false }]]}>
          {markdown}
        </ReactMarkdown>
      </div>
    </>
  );
}
